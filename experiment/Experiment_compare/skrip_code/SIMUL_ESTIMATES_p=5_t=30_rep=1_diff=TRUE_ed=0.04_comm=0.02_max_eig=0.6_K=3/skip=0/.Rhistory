# Copyright 2017, Andrey Skripnikov, All rights reserved.
#setwd("/home/usdandres/Downloads/Revision/")
source("./function.R")
set.seed(2)
###########
## Code for simulated experiment:
## comparing joint and separate approaches for estimating TWO simulated Granger networks.
## (code needs some adjustments for higher number K of networks)
##
## Here is the layout of the code:
##   1. User-defined parameters(all variable descriptions are given next to parameters)
##   2. Data generation(both stationary transition matrices,
##                      both error covariance matrices that follow K-factor model,
##                      both simulated time series following the VAR model)
##   3. Separate estimation.
##   4. Joint estimation.
##   5. Printing all the results(details of each performance measure are given
##                               in the end)
##
## Separate estimation is done in Simul.Data.Separate.Main() function
## that takes no arguments but uses global variables.
## Summary of what it does:
##     - initializes both error covariance matrices with identities,
##     - estimates transition matrix for each entity separately via l1-estimation
##   and AIC criterion for tuning parameter selection,
##     - uses the transition matrix estimates to get residuals,
##     - use residuals as data to estimate error inverse covariance matrices
##   with help of L-factor model and graphical lasso separately,
##     - plug-in the resulting inverse error covariance estimates and re-estimate
##   transition matrices separately for each entity via l1-estimation and AIC
##   criterion for tuning parameter selection,
##   For more details on the code - see Paper.functions.R
##
## Joint estimation is done in Simul.Data.Joint.Main() function
## that takes no arguments but uses global variables.
##
## Summary of what it does:
##     - uses the estimates of inverse error covariances from the separate estimation process
##       (just plugs them in)
##     - combines both entites into one standardized dataset, sets up the generalized
##       fused lasso as discussed in paper with two tuning parameters lambda1 and lambda2
##     - does sequential search of tuning parameter values: fix lambda2, grid search for lambda1.est,
##       fix lambda1=lambda1.est, grid search for lambda2.est, fix lambda2=lambda2.est etc etc
##     - criterion used for search: AIC distinct(described in Paper.functions.R)
##     - the fusion of parameters is done with help of ADMM algorithm, described
##       in detail in the paper and in Paper.functions.R,
##     - refitting the estimate using the structure(skeleton) of the original
##     estimate: get rid of columns of data matrix(that COMBINES entities)
##     that correspond to zero elements in the original estimate,
##     fit a regression with a tiny sparsity penalty
##     (to shrink elements a little bit, but so that none of them are 0)
## For more details on how the code functions work see Paper.function.R.
########################################
####  USER-DEFINED PARAMETERS         ##
########################################
### General parameters
K <- 3                     # number of entities
p <- 10                     # number of variables per entity
train <- 30                  # number of training points per entity
rep <- 1                       # Number of replicates
skip <- 0                       # For code reproducibility: in case I'd like to rerun 50 replicates for the same seed,
# but running them in a single program would take too long, and I have to break it into chunks of 5-10 replicates.
max_eig <- 0.6            # max eigenvalue of VAR transition matrices
diff = TRUE               # whether to generate same or different matrices for two entities
h <- 1                      # h-step forecasts will be made
test <- train + 1:h         # test time points(to measure forecasting precision) per entity
t <- train + h              # total number of time points per entity
SNR <- 2                    # Signal-to-Noise ratio
L <- 2                     # number of factors for the L-factor model per entity
sigma.iter <- 2           # number of iterations for error covariance estimation procedure
ed <- 0.04               # off-diagonal edge density shared for both entities
comm <- 0.02               # off-diagonal edge density specific for each entity
Results <- matrix(0,rep,10) # performance measures put into one vector:
# Pred.Err.Joint, FP.Joint, FN.Joint, Matt.Coef.Joint,
# Frob.Joint, Pred.Err.Sep, FP.Sep, FN.Sep,
# Matt.Coef.Sep, Frob.Sep
Results.General <- matrix(0,rep,6) # performance measures put into one vector:
#### criterions for tuning parameter selection
criter.joint.1 <- "AICc"  # criterion to select sparsity parameter for joint estimates
criter.joint.2 <- "BIC.dist" # criterion to select fusion parameter for joint estimates
criter.sep <- "AICc"       # criterion to select sparsity parameter for separate estimates
df.sep <- 2                     # the multiplier for "degrees of freedom" part of the criterion for SEPARATE
### parameters for glmnet() function performing solution path calculation for standard lasso problem
fail <- 0
fail.thresh <- 0.7
intercept <- FALSE
standardize <- TRUE
### ADMM algorithm parameters ###
rho <- 10                   # ADMM rho penalty parameter
init <- "0"                 # initialize ADMM with Identity("1"),Zero-matrix("0"), or with separate estimates
eps <- 0.001           # stopping criterion
iter.thresh <- 200     # max number of iterations per one run of ADMM algorithm
fused.thresh <- 0.01  # threshold for differences between elements
n.iter <- 1            # number of sequential iterations
### lambda grid parameters
knots1 <- 15                                           # controls lower bound of lambda1 path
knots2 <- 20                                           # controls lower bound of lambda2 path
L1 <- NULL                                              # length of lambda1 grid(NULL means we calculate lambda1 path automatically)
L2 <- 20                                                # length of lambda2 grid
#lambda.path <- 1*(1/2)^seq(0, knots1, length = L1)     # lambda1 grid
#L1 <- length(lambda.path)
lambda2.path <- c((2*p)*rho*(1/2)^seq(0, knots1, length = L2),0)   # lambda2 grid, making sure we capture the whole specter of fusion:
# from identical A11=A22(for high values of lambda2) to dissimilar A11 and A22(low values of lambda2)
L2 <- length(lambda2.path)
### Thresholding parameters
ConstThresh <- TRUE         # whether to use the hard threshold for final estimates
Thresh <- 0.1               # the value of hard threshold for the final estimate
#criter.sep <- "AIC"        # the criterion to use for tuning parameter selection
df <- 2                     # for AIC.dist
################################################
## Printing out all the main parameter values ##
################################################
print(c("p:",p))
print(c("t:",t))
print(c("Init:",init))
print(c("criter.joint.1:",criter.joint.1))
print(c("criter.joint.2:",criter.joint.2))
print(c("criter.sep:",criter.sep))
print(c("df.sep",df.sep))
print(c("rho:",rho))
print(c("fail.thresh=",fail.thresh))
print(c("L:",L))
print(c("SNR:",SNR))
print(c("diff:",diff))
print(c("rep",rep))
print(c("skip",skip))
print(c("ConstThresh",ConstThresh))
print(c("Thresh",Thresh))
print(c("l_lambda1.path",L1))
#print(c("lambda1:",lambda.path))
print(c("lambda2:",lambda2.path))
print(c("eps:",eps))
print(c("iter.thresh",iter.thresh))
print(c("ed:",ed))
print(c("comm:",comm))
print(c("max_eig:",max_eig))
print(c("n.iter:",n.iter))
source("skrip_main.R")
setwd("~/Documents/JGranger_ncvx/experiment/Experiment_compare/skrip_code")
source("skrip_main.R")
source("./function.R")
library(plotrix)
library(plotrix)
library(glmnet)
library(MASS)
library(glasso)
library(methods)
source("skrip_main.R")
source("skrip_main.R")
source("skrip_main.R")
source("skrip_main.R")
A.true
dim(A.true)
dim(A.true[1])
dim(A.true[[1])
dim(A.true[[1]])
Atmp
View(A.true.vec)
View(A.true)
View(A.true)
source("skrip_main.R")
A11
A11
source("skrip_main.R")
A11.true
A22.true
A.true
source("skrip_main.R")
source("skrip_main.R")
A.true
A.true[[1]][1]
A.true[[1]][2]
A.true[[1]][3]
A.true[[1]][1]
A.true
A.true.vec
source("skrip_main.R")
source("skrip_main.R")
A.true
source("skrip_main.R")
Atmp
source("skrip_main.R")
Atmp
K
source("skrip_main.R")
Atmp_vec
source("skrip_main.R")
source("skrip_main.R")
Atmp
Atmp == 0.6
Atmp == A.true
run
Atmp == A.true[[run]]
Atmp == A.true[[run]]
View(A.true)
oo = A.true[[1]]
View(A.true)
View(oo)
View(Atmp)
View(oo)
oo-Atmp
Atmp[1]==oo[1]
Atmp[1]
oo[1]
mapply('-', Atmp, oo, SIMPLIFY = FALSE)
mapply('-', A.true.vec, Atmp.vec, SIMPLIFY = FALSE)
mapply('-', A.true.vec, Atmp_vec, SIMPLIFY = FALSE)
View(Atmp_vec)
View(A.true.vec)
View(Atmp_vec)
View(A.true.vec)
class(Atmp_vec)
class(A.true.vec)
test = cbind(matrix(t(Simul.Obj$A.true[[1]]),1,p^2),matrix(t(Simul.Obj$A.true[[2]]),1,p^2))
View(test)
test = cbind(matrix(t(Simul.Obj$A.true[[1]]),1,p^2))
View(test)
View(test)
View(test)
rm("test")
test
test = cbind(matrix(t(Simul.Obj$A.true[[1]]),1,p^2))
dim(test)
test = cbind(test,matrix(t(Simul.Obj$A.true[[2]]),1,p^2))
dim(test)
result = mapply('-', A.true.vec, test, SIMPLIFY = FALSE);
View(result)
View(result)
all(result==0)
source("skrip_main.R")
source("skrip_main.R")
source("skrip_main.R")
Separate.Est.Obj
source("skrip_main.R")
source("skrip_main.R")
source("skrip_main.R")
Lm
source("skrip_main.R")
Lm
Lm %*% as.matrix(A.init)
A.init
dim(A.init)
length(A.init)
source("skrip_main.R")
source("skrip_main.R")
A.init
length(A.init)
(as.matrix(A.init))
size(Lm)
length(Lm)
dim(Lm)
5*5*3
5*5*2
source("skrip_main.R")
source("skrip_main.R")
source("skrip_main.R")
source("skrip_main.R")
source("skrip_main.R")
A.init
length(A.init)
source("skrip_main.R")
source("skrip_main.R")
source("skrip_main.R")
source("skrip_main.R")
source("skrip_main.R")
A.init
length(A.init)
5*5*3
source("skrip_main.R")
source("skrip_main.R")
beta.next
source("skrip_main.R")
A.init
length(A.init)
length(A.init)
source("skrip_main.R")
length(A.init)
length(A.init)
source("skrip_main.R")
length(A.init)
K
iteration_k
c(A.init,matrix(diag(1,p),byrow=TRUE))
matrix(diag(1,p)
)
source("skrip_main.R")
A.init
length(A.init)
source("skrip_main.R")
length(A.init)
length(A.init)
source("skrip_main.R")
length(A.init)
source("skrip_main.R")
length(A.init)
length(A.init)
source("skrip_main.R")
source("skrip_main.R")
source("skrip_main.R")
source("skrip_main.R")
source("skrip_main.R")
source("skrip_main.R")
source("skrip_main.R")
source("skrip_main.R")
